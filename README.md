# DesignPattern

- DesignPattern Implement By java, python, go...

模式名称|java8|python3.5|go1.7
----|----|----|----
[抽象工厂模式](#user-content-抽象工厂模式)|[AbstractFactoryPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/AbstractFactoryPattern/AbstractFactoryPattern.java)|[AbstractFactory.py](https://github.com/JiangKlijna/DesignPattern/blob/master/AbstractFactoryPattern/AbstractFactory.py)|X
[适配器模式](#user-content-适配器模式)|[AdapterPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/AdapterPattern/AdapterPattern.java)|[Adapter.py](https://github.com/JiangKlijna/DesignPattern/blob/master/AdapterPattern/Adapter.py)|X
[桥接模式](#user-content-桥接模式)|[BridgePattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/BridgePattern/BridgePattern.java)|[Bridge.py](https://github.com/JiangKlijna/DesignPattern/blob/master/BridgePattern/Bridge.py)|X
[建造者模式](#user-content-建造者模式)|[BuilderPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/BuilderPattern/BuilderPattern.java)|[Builder.py](https://github.com/JiangKlijna/DesignPattern/blob/master/BuilderPattern/Builder.py)|X
[责任链模式](#user-content-责任链模式)|[ChainPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/ChainPattern/ChainPattern.java)|[Chain.py](https://github.com/JiangKlijna/DesignPattern/blob/master/ChainPattern/Chain.py)|X
[命令模式](#user-content-命令模式)|[CommandPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/CommandPattern/CommandPattern.java)|[Command.py](https://github.com/JiangKlijna/DesignPattern/blob/master/CommandPattern/Command.py)|X
[组合模式](#user-content-组合模式)|[CompositePattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/CompositePattern/CompositePattern.java)|[Composite.py](https://github.com/JiangKlijna/DesignPattern/blob/master/CompositePattern/Composite.py)|X
[装饰模式](#user-content-装饰模式)|[DecoratorPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/DecoratorPattern/DecoratorPattern.java)|[Decorator.py](https://github.com/JiangKlijna/DesignPattern/blob/master/DecoratorPattern/Decorator.py)|X
[外观模式](#user-content-外观模式)|[FacadePattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/FacadePattern/FacadePattern.java)|[Facade.py](https://github.com/JiangKlijna/DesignPattern/blob/master/FacadePattern/Facade.py)|X
[工厂模式](#user-content-工厂模式)|[FactoryPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/FactoryPattern/FactoryPattern.java)|[Factory.py](https://github.com/JiangKlijna/DesignPattern/blob/master/FactoryPattern/Factory.py)|X
[享元模式](#user-content-享元模式)|[FlyweightPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/FlyweightPattern/FlyweightPattern.java)|[Flyweight.py](https://github.com/JiangKlijna/DesignPattern/blob/master/FlyweightPattern/Flyweight.py)|X
[解释器模式](#user-content-解释器模式)|[InterpreterPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/InterpreterPattern/InterpreterPattern.java)|[Interpreter.py](https://github.com/JiangKlijna/DesignPattern/blob/master/InterpreterPattern/Interpreter.py)|X
[迭代器模式](#user-content-迭代器模式)|[IteratorPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/IteratorPattern/IteratorPattern.java)|[Iterator.py](https://github.com/JiangKlijna/DesignPattern/blob/master/IteratorPattern/Iterator.py)|X
[中介模式](#user-content-中介模式)|[MediatorPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/MediatorPattern/MediatorPattern.java)|[Mediator.py](https://github.com/JiangKlijna/DesignPattern/blob/master/MediatorPattern/Mediator.py)|X
[备忘录模式](#user-content-观察者模式)|[MementoPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/MementoPattern/MementoPattern.java)|[Memento.py](https://github.com/JiangKlijna/DesignPattern/blob/master/MementoPattern/Memento.py)|X
[观察者模式](#user-content-)|[ObserverPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/ObserverPattern/ObserverPattern.java)|[Observer.py](https://github.com/JiangKlijna/DesignPattern/blob/master/ObserverPattern/Observer.py)|X
[原型模式](#user-content-原型模式)|[PrototypePattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/PrototypePattern/PrototypePattern.java)|[Prototype.py](https://github.com/JiangKlijna/DesignPattern/blob/master/PrototypePattern/Prototype.py)|X
[代理模式](#user-content-代理模式)|[ProxyPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/ProxyPattern/ProxyPattern.java)|[Proxy.py](https://github.com/JiangKlijna/DesignPattern/blob/master/ProxyPattern/Proxy.py)|X
[单例模式](#user-content-单例模式)|[SingletonPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/SingletonPattern/SingletonPattern.java)|[Singleton.py](https://github.com/JiangKlijna/DesignPattern/blob/master/SingletonPattern/Singleton.py)|X
[状态模式](#user-content-状态模式)|[StatePattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/StatePattern/StatePattern.java)|[State.py](https://github.com/JiangKlijna/DesignPattern/blob/master/StatePattern/State.py)|X
[策略模式](#user-content-策略模式)|[StrategyPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/StrategyPattern/StrategyPattern.java)|[Strategy.py](https://github.com/JiangKlijna/DesignPattern/blob/master/StrategyPattern/Strategy.py)|X
[模板方法模式](#user-content-模板方法模式)|[TemplatePattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/TemplatePattern/TemplatePattern.java)|[Template.py](https://github.com/JiangKlijna/DesignPattern/blob/master/TemplatePattern/Template.py)|X
[访问者模式](#user-content-访问者模式)|[VisitorPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/VisitorPattern/VisitorPattern.java)|[Visitor.py](https://github.com/JiangKlijna/DesignPattern/blob/master/VisitorPattern/Visitor.py)|X

- 设计模式所支持的设计的可变方面

目的|设计模式|可变的方向
----|----|----
创建|AbstractFactory|产品对象家族
......|Builder|如何创建一个组合对象
......|Factory|被实例化的子类
......|Prototype|实例化的子类
......|Singleton|一个类的惟一实例
结构|Adapter|对象的接口
......|Bridge|对象的实现
......|Composite|一个对象的结构和组成
......|Decorator|对象的职责,不生成子类
......|Facade|一个子系统的接口
......|Flyweight|对象的存储开销
......|Proxy|如何访问一个对象;该对象的位置
行为|Chain|满足一个请求的对象
......|Command|何时,怎样满足一个对象
......|Interpreter|一个语言的文法及解释
......|Iterator|如何遍历,访问一个聚合的各元素
......|Mediator|对象间怎样交互,和谁交互
......|Memento|一个对象中哪些私有信息存放在该对象之外,以及在什么时候存储
......|Observer|多个对象依赖于另外一个对象,而这些对象又如何保持一致
......|State|对象的状态
......|Strategy|算法
......|Template|算法中的某些步骤
......|Visitor|某些可以作用于一个(组)对象上的操作,但不能修改这些对象的类

- 设计模式描述

#### 抽象工厂模式
* 意图
  * 提供一个创建一系列相关或相互依赖对象的接口,而无需指定他们具体的类
* 适用性
  * 一个系统要独立于它的产品的创建,组合和表示时
  * 一个系统要由多个产品系列中的一个来配置时
  * 当你要强调一系列相关的产品对象的设计以便进行联合使用时
  * 当你提供一个产品类库,而只想显示它们的接口而不是实现时

#### 适配器模式
* 意图
  * 将一个类的接口转换成客户希望的另外一个接口,使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
* 适用性
  * 你想使用一个已经存在的类,而他的接口不符合你的需求
  * 你想创建一个可以复用的类,该类可以与其他不相关的类或不可预见的类(即那些接口可能不一定兼容的类)协同工作
  * (仅适用于对象Adapter)你想使用一些已经存在的类,但是不可能对每一个都进行子类化以匹配它们的接口.对象适配器可以适配它的父类接口

#### 桥接模式
* 意图
  * 将抽象部分与它的实现部分分离,使它们都可以独立地变化
* 适用性
  * 你不希望在抽象和它的实现部分之间有一个固定的绑定关系,这种情况可能是因为,在程序运行时刻实现部分应可以被选择或者切换
  * 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充,这时使你可以对不同的抽象接口和实现部分进行组合,并分别对它们进行扩充
  * 对一个抽象的实现部分的修改应对客户不产生影响,即客户的代码不必重新编译

#### 建造者模式
* 意图
  * 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示
* 适用性
  * 当创建负责对象的算法应该独立于该对象的组成部分以及它们的装配方式时
  * 当构造过程必须允许被构造的对象有不同的表示时

#### 责任链模式
* 意图
  * 使多个对象都有机会处理请求,从而避免请求的发送者和接收者之前的耦合关系.将这些对象模式连成一条链,并沿着这条链传递该请求,直到有一个对象处理它为止
* 适用性
  * 有多个对象可以处理一个请求,哪个对象处理运行时刻自动确定
  * 你想在不明确指定接收者的情况下,向多个对象中的一个提交一个请求
  * 可以处理一个请求的对象集合应被动态指定

#### 命令模式
* 意图
  * 将一个请求封装成为一个对象,从而使你可用不同的请求对客户进行参数初始化;对请求排队或记录请求日志,以及支持可撤销的操作
* 适用性
  * 抽象出待执行的动作以参数化某对象
  * 在不同的时刻指定,排列和执行请求
  * 支持取消操作
  * 支持修改日志,这样当系统崩溃时,这些修改可以被重做一遍
  * 用构建在原语操作上的高层操作构造一个系统

#### 组合模式
* 意图
  * 将对象组合成树形结构以表示"部分 -整体"的层次结构.Composite使得用户对单个对象和组合对象的使用具有一致性.
* 适用性
  * 你想表示对象的部分-整体层次结构.
  * 你希望用户忽略组合对象与单个对象的不同,用户将统一地使用组合结构中的所有对象.

#### 装饰模式
* 意图
  * 动态地给一个对象添加一些额外的职责.就增加功能来说,Decorator模式相比生成子类更为灵活.
* 适用性
  * 在不影响其他对象的情况下,以动态、透明的方式给单个对象添加职责.
  * 处理那些可以撤消的职责.
  * 当不能采用生成子类的方法进行扩充时.一种情况是,可能有大量独立的扩展,为支持每一种组合将产生大量的子类,使得子类数目呈爆炸性增长.另一种情况可能是因为类定义被隐藏,或类定义不能用于生成子类.

#### 外观模式
* 意图
  * 为子系统中的一组接口提供一个一致的界面, Facade模式定义了一个高层接口,这个接口使得这一子系统更加容易使用.
* 适用性
  * 当你要为一个复杂子系统提供一个简单接口时.子系统往往因为不断演化而变得越来越复杂.大多数模式使用时都会产生更多更小的类.这使得子系统更具可重用性,也更容易对子系统进行定制,但这也给那些不需要定制子系统的用户带来一些使用上的困难.Facade可以提供一个简单的缺省视图,这一视图对大多数用户来说已经足够,而那些需要更多的可定制性的用户可以越过facade层.
  * 客户程序与抽象类的实现部分之间存在着很大的依赖性.引入 facade将这个子系统与客户以及其他的子系统分离,可以提高子系统的独立性和可移植性.
  * 当你需要构建一个层次结构的子系统时,使用 facade模式定义子系统中每层的入口点.如果子系统之间是相互依赖的,你可以让它们仅通过 facade进行通讯,从而简化了它们之间的依赖关系.


#### 工厂模式
* 意图
  * 定义一个用于创建对象的接口,让子类决定实例化哪一个类. Factory Method使一个类的实例化延迟到其子类.
* 适用性
  * 当一个类不知道它所必须创建的对象的类的时候.
  * 当一个类希望由它的子类来指定它所创建的对象的时候.
  * 当类将创建对象的职责委托给多个帮助子类中的某一个,并且你希望将哪一个帮助子类是代理者这一信息局部化的时候.
