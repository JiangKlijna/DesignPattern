# DesignPattern

- DesignPattern Implement By java, python...

模式名称|java8|python3.5|X
----|----|----|----
[抽象工厂模式](#user-content-抽象工厂模式)|[AbstractFactoryPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/AbstractFactoryPattern/AbstractFactoryPattern.java)|[AbstractFactory.py](https://github.com/JiangKlijna/DesignPattern/blob/master/AbstractFactoryPattern/AbstractFactory.py)|X
[适配器模式](#user-content-适配器模式)|[AdapterPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/AdapterPattern/AdapterPattern.java)|[Adapter.py](https://github.com/JiangKlijna/DesignPattern/blob/master/AdapterPattern/Adapter.py)|X
[桥接模式](#user-content-桥接模式)|[BridgePattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/BridgePattern/BridgePattern.java)|[Bridge.py](https://github.com/JiangKlijna/DesignPattern/blob/master/BridgePattern/Bridge.py)|X
[建造者模式](#user-content-建造者模式)|[BuilderPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/BuilderPattern/BuilderPattern.java)|[Builder.py](https://github.com/JiangKlijna/DesignPattern/blob/master/BuilderPattern/Builder.py)|X
[责任链模式](#user-content-责任链模式)|[ChainPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/ChainPattern/ChainPattern.java)|[Chain.py](https://github.com/JiangKlijna/DesignPattern/blob/master/ChainPattern/Chain.py)|X
[命令模式](#user-content-命令模式)|[CommandPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/CommandPattern/CommandPattern.java)|[Command.py](https://github.com/JiangKlijna/DesignPattern/blob/master/CommandPattern/Command.py)|X
[组合模式](#user-content-组合模式)|[CompositePattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/CompositePattern/CompositePattern.java)|[Composite.py](https://github.com/JiangKlijna/DesignPattern/blob/master/CompositePattern/Composite.py)|X
[装饰模式](#user-content-装饰模式)|[DecoratorPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/DecoratorPattern/DecoratorPattern.java)|[Decorator.py](https://github.com/JiangKlijna/DesignPattern/blob/master/DecoratorPattern/Decorator.py)|X
[外观模式](#user-content-外观模式)|[FacadePattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/FacadePattern/FacadePattern.java)|[Facade.py](https://github.com/JiangKlijna/DesignPattern/blob/master/FacadePattern/Facade.py)|X
[工厂模式](#user-content-工厂模式)|[FactoryPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/FactoryPattern/FactoryPattern.java)|[Factory.py](https://github.com/JiangKlijna/DesignPattern/blob/master/FactoryPattern/Factory.py)|X
[享元模式](#user-content-享元模式)|[FlyweightPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/FlyweightPattern/FlyweightPattern.java)|[Flyweight.py](https://github.com/JiangKlijna/DesignPattern/blob/master/FlyweightPattern/Flyweight.py)|X
[解释器模式](#user-content-解释器模式)|[InterpreterPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/InterpreterPattern/InterpreterPattern.java)|[Interpreter.py](https://github.com/JiangKlijna/DesignPattern/blob/master/InterpreterPattern/Interpreter.py)|X
[迭代器模式](#user-content-迭代器模式)|[IteratorPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/IteratorPattern/IteratorPattern.java)|[Iterator.py](https://github.com/JiangKlijna/DesignPattern/blob/master/IteratorPattern/Iterator.py)|X
[中介模式](#user-content-中介模式)|[MediatorPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/MediatorPattern/MediatorPattern.java)|[Mediator.py](https://github.com/JiangKlijna/DesignPattern/blob/master/MediatorPattern/Mediator.py)|X
[备忘录模式](#user-content-观察者模式)|[MementoPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/MementoPattern/MementoPattern.java)|[Memento.py](https://github.com/JiangKlijna/DesignPattern/blob/master/MementoPattern/Memento.py)|X
[观察者模式](#user-content-)|[ObserverPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/ObserverPattern/ObserverPattern.java)|[Observer.py](https://github.com/JiangKlijna/DesignPattern/blob/master/ObserverPattern/Observer.py)|X
[原型模式](#user-content-原型模式)|[PrototypePattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/PrototypePattern/PrototypePattern.java)|[Prototype.py](https://github.com/JiangKlijna/DesignPattern/blob/master/PrototypePattern/Prototype.py)|X
[代理模式](#user-content-代理模式)|[ProxyPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/ProxyPattern/ProxyPattern.java)|[Proxy.py](https://github.com/JiangKlijna/DesignPattern/blob/master/ProxyPattern/Proxy.py)|X
[单例模式](#user-content-单例模式)|[SingletonPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/SingletonPattern/SingletonPattern.java)|[Singleton.py](https://github.com/JiangKlijna/DesignPattern/blob/master/SingletonPattern/Singleton.py)|X
[状态模式](#user-content-状态模式)|[StatePattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/StatePattern/StatePattern.java)|[State.py](https://github.com/JiangKlijna/DesignPattern/blob/master/StatePattern/State.py)|X
[策略模式](#user-content-策略模式)|[StrategyPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/StrategyPattern/StrategyPattern.java)|[Strategy.py](https://github.com/JiangKlijna/DesignPattern/blob/master/StrategyPattern/Strategy.py)|X
[模板方法模式](#user-content-模板方法模式)|[TemplatePattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/TemplatePattern/TemplatePattern.java)|[Template.py](https://github.com/JiangKlijna/DesignPattern/blob/master/TemplatePattern/Template.py)|X
[访问者模式](#user-content-访问者模式)|[VisitorPattern.java](https://github.com/JiangKlijna/DesignPattern/blob/master/VisitorPattern/VisitorPattern.java)|[Visitor.py](https://github.com/JiangKlijna/DesignPattern/blob/master/VisitorPattern/Visitor.py)|X

- 设计模式所支持的设计的可变方面(设计模式可复用面向对象软件设计基础)

目的|设计模式|可变的方向
----|----|----
创建|AbstractFactory|产品对象家族
......|Builder|如何创建一个组合对象
......|Factory|被实例化的子类
......|Prototype|实例化的子类
......|Singleton|一个类的惟一实例
结构|Adapter|对象的接口
......|Bridge|对象的实现
......|Composite|一个对象的结构和组成
......|Decorator|对象的职责,不生成子类
......|Facade|一个子系统的接口
......|Flyweight|对象的存储开销
......|Proxy|如何访问一个对象;该对象的位置
行为|Chain|满足一个请求的对象
......|Command|何时,怎样满足一个对象
......|Interpreter|一个语言的文法及解释
......|Iterator|如何遍历,访问一个聚合的各元素
......|Mediator|对象间怎样交互,和谁交互
......|Memento|一个对象中哪些私有信息存放在该对象之外,以及在什么时候存储
......|Observer|多个对象依赖于另外一个对象,而这些对象又如何保持一致
......|State|对象的状态
......|Strategy|算法
......|Template|算法中的某些步骤
......|Visitor|某些可以作用于一个(组)对象上的操作,但不能修改这些对象的类

- 设计模式描述(设计模式可复用面向对象软件设计基础)

#### 抽象工厂模式
* 意图
  * 提供一个创建一系列相关或相互依赖对象的接口,而无需指定他们具体的类
* 适用性
  * 一个系统要独立于它的产品的创建,组合和表示时
  * 一个系统要由多个产品系列中的一个来配置时
  * 当你要强调一系列相关的产品对象的设计以便进行联合使用时
  * 当你提供一个产品类库,而只想显示它们的接口而不是实现时

#### 适配器模式
* 意图
  * 将一个类的接口转换成客户希望的另外一个接口,使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
* 适用性
  * 你想使用一个已经存在的类,而他的接口不符合你的需求
  * 你想创建一个可以复用的类,该类可以与其他不相关的类或不可预见的类(即那些接口可能不一定兼容的类)协同工作
  * (仅适用于对象Adapter)你想使用一些已经存在的类,但是不可能对每一个都进行子类化以匹配它们的接口.对象适配器可以适配它的父类接口

#### 桥接模式
* 意图
  * 将抽象部分与它的实现部分分离,使它们都可以独立地变化
* 适用性
  * 你不希望在抽象和它的实现部分之间有一个固定的绑定关系,这种情况可能是因为,在程序运行时刻实现部分应可以被选择或者切换
  * 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充,这时使你可以对不同的抽象接口和实现部分进行组合,并分别对它们进行扩充
  * 对一个抽象的实现部分的修改应对客户不产生影响,即客户的代码不必重新编译

#### 建造者模式
* 意图
  * 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示
* 适用性
  * 当创建负责对象的算法应该独立于该对象的组成部分以及它们的装配方式时
  * 当构造过程必须允许被构造的对象有不同的表示时

#### 责任链模式
* 意图
  * 使多个对象都有机会处理请求,从而避免请求的发送者和接收者之前的耦合关系.将这些对象模式连成一条链,并沿着这条链传递该请求,直到有一个对象处理它为止
* 适用性
  * 有多个对象可以处理一个请求,哪个对象处理运行时刻自动确定
  * 你想在不明确指定接收者的情况下,向多个对象中的一个提交一个请求
  * 可以处理一个请求的对象集合应被动态指定

#### 命令模式
* 意图
  * 将一个请求封装成为一个对象,从而使你可用不同的请求对客户进行参数初始化;对请求排队或记录请求日志,以及支持可撤销的操作
* 适用性
  * 抽象出待执行的动作以参数化某对象
  * 在不同的时刻指定,排列和执行请求
  * 支持取消操作
  * 支持修改日志,这样当系统崩溃时,这些修改可以被重做一遍
  * 用构建在原语操作上的高层操作构造一个系统

#### 组合模式
* 意图
  * 将对象组合成树形结构以表示"部分 -整体"的层次结构.Composite使得用户对单个对象和组合对象的使用具有一致性.
* 适用性
  * 你想表示对象的部分-整体层次结构.
  * 你希望用户忽略组合对象与单个对象的不同,用户将统一地使用组合结构中的所有对象.

#### 装饰模式
* 意图
  * 动态地给一个对象添加一些额外的职责.就增加功能来说,Decorator模式相比生成子类更为灵活.
* 适用性
  * 在不影响其他对象的情况下,以动态、透明的方式给单个对象添加职责.
  * 处理那些可以撤消的职责.
  * 当不能采用生成子类的方法进行扩充时.一种情况是,可能有大量独立的扩展,为支持每一种组合将产生大量的子类,使得子类数目呈爆炸性增长.另一种情况可能是因为类定义被隐藏,或类定义不能用于生成子类.

#### 外观模式
* 意图
  * 为子系统中的一组接口提供一个一致的界面, Facade模式定义了一个高层接口,这个接口使得这一子系统更加容易使用.
* 适用性
  * 当你要为一个复杂子系统提供一个简单接口时.子系统往往因为不断演化而变得越来越复杂.大多数模式使用时都会产生更多更小的类.这使得子系统更具可重用性,也更容易对子系统进行定制,但这也给那些不需要定制子系统的用户带来一些使用上的困难.Facade可以提供一个简单的缺省视图,这一视图对大多数用户来说已经足够,而那些需要更多的可定制性的用户可以越过facade层.
  * 客户程序与抽象类的实现部分之间存在着很大的依赖性.引入 facade将这个子系统与客户以及其他的子系统分离,可以提高子系统的独立性和可移植性.
  * 当你需要构建一个层次结构的子系统时,使用 facade模式定义子系统中每层的入口点.如果子系统之间是相互依赖的,你可以让它们仅通过 facade进行通讯,从而简化了它们之间的依赖关系.


#### 工厂模式
* 意图
  * 定义一个用于创建对象的接口,让子类决定实例化哪一个类. Factory Method使一个类的实例化延迟到其子类.
* 适用性
  * 当一个类不知道它所必须创建的对象的类的时候.
  * 当一个类希望由它的子类来指定它所创建的对象的时候.
  * 当类将创建对象的职责委托给多个帮助子类中的某一个,并且你希望将哪一个帮助子类是代理者这一信息局部化的时候.

#### 享元模式
* 意图
  * 运用共享技术有效地支持大量细粒度的对象.
* 适用性
  * 一个应用程序使用了大量的对象.
  * 完全由于使用大量的对象,造成很大的存储开销.
  * 对象的大多数状态都可变为外部状态.
  * 如果删除对象的外部状态,那么可以用相对较少的共享对象取代很多组对象.
  * 应用程序不依赖于对象标识.由于Flyweight对象可以被共享,对于概念上明显有别的对象,标识测试将返回真值.

#### 解释器模式
* 意图
  * 给定一个语言,定义它的文法的一种表示,并定义一个解释器,这个解释器使用该表示
来解释语言中的句子.
* 适用性
  * 该文法简单对于复杂的文法 , 文法的类层次变得庞大而无法管理.此时语法分析程序生成器这样的工具是更好的选择.它们无需构建抽象语法树即可解释表达式 , 这样可以节省空间而且还可能节省时间.
  * 效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的 , 而是首先将它们转换成另一种形式.例如,正则表达式通常被转换成状态机.但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的.

#### 迭代器模式
* 意图
  * 提供一种方法顺序访问一个聚合对象中各个元素 , 而又不需暴露该对象的内部表示.
* 适用性
  * 访问一个聚合对象的内容而无需暴露它的内部表示.
  * 支持对聚合对象的多种遍历.
  * 为遍历不同的聚合结构提供一个统一的接口 (即, 支持多态迭代).

#### 中介模式
* 意图
  * 用一个中介对象来封装一系列的对象交互.中介者使各对象不需要显式地相互引用,从而使其耦合松散,而且可以独立地改变它们之间的交互.
* 适用性
  * 一组对象以定义良好但是复杂的方式进行通信.产生的相互依赖关系结构混乱且难以理解.
  * 一个对象引用其他很多对象并且直接与这些对象通信 ,导致难以复用该对象.
  * 想定制一个分布在多个类中的行为,而又不想生成太多的子类.

#### 备忘录模式
* 意图
  * 在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态. 这样以后就可将该对象恢复到原先保存的状态.
* 适用性
  * 必须保存一个对象在某一个时刻的 (部分)状态, 这样以后需要时它才能恢复到先前的状态.
  * 如果一个用接口来让其它对象直接得到这些状态,将会暴露对象的实现细节并破坏对象的封装性.

#### 观察者模式
* 意图
  * 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新.
* 适用性
  * 当一个抽象模型有两个方面 , 其中一个方面依赖于另一方面.将这二者封装在独立的对 象中以使它们可以各自独立地改变和复用.
  * 当对一个对象的改变需要同时改变其它对象 , 而不知道具体有多少对象有待改变.
  * 当一个对象必须通知其它对象,而它又不能假定其它对象是谁.换言之 , 你不希望这些对象是紧密耦合的.

#### 原型模式
* 意图
  * 用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象.
* 适用性
  * 当要实例化的类是在运行时刻指定时,例如,通过动态装载;或者
  * 为了避免创建一个与产品类层次平行的工厂类层次时;或者
  * 当一个类的实例只能有几个不同状态组合中的一种时.建立相应数目的原型并克隆它们 可能比每次用合适的状态手工实例化该类更方便一些
